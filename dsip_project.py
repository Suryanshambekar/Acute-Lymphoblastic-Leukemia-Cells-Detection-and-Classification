# -*- coding: utf-8 -*-
"""DSIP Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1snrFog8hxr5qd4u95j5G4IUlNzDYqEk1
"""

!pip install ultralytics
!pip install roboflow
!pip install opencv-python

from roboflow import Roboflow
rf = Roboflow(api_key="K3H5z59rmbmSHmWlpuLv")
project = rf.workspace("custom-yolov5-o0hdb").project("leukemia-cancer-detection")
version = project.version(6)
dataset = version.download("yolov8")

import kagglehub

# Download latest version
path = kagglehub.dataset_download("mehradaria/leukemia")

print("Path to dataset files:", path)
#/root/.cache/kagglehub/datasets/mehradaria/leukemia/versions/1/Original
#/root/.cache/kagglehub/datasets/mehradaria/leukemia/versions/1/Original/Benign

from ultralytics import YOLO

# Save data.yaml with corrected paths temporarily
corrected_yaml = """
train: /content/Leukemia-Cancer-Detection-6/train/images
val: /content/Leukemia-Cancer-Detection-6/valid/images
test: /content/Leukemia-Cancer-Detection-6/test/images
nc: 4
names: ['Benign', 'Early', 'Pre', 'Pro']
"""

# Write to a temp file
with open("temp_data.yaml", "w") as f:
    f.write(corrected_yaml)

# Train the model
model = YOLO("yolov8n.pt")
model.train(data="temp_data.yaml", epochs=5, imgsz=640, batch=16)

metrics = model.val()
print(metrics)

print(f"Precision: {metrics.results_dict['metrics/precision(B)']}")
print(f"Recall: {metrics.results_dict['metrics/recall(B)']}")
print(f"mAP50: {metrics.results_dict['metrics/mAP50(B)']}")
print(f"mAP50-95: {metrics.results_dict['metrics/mAP50-95(B)']}")

import matplotlib.pyplot as plt

# Assuming you have already calculated and stored the metrics in the 'metrics' variable
# as shown in your previous code snippet.

# Extract the metric values
precision = metrics.results_dict['metrics/precision(B)']
recall = metrics.results_dict['metrics/recall(B)']
mAP50 = metrics.results_dict['metrics/mAP50(B)']
mAP50_95 = metrics.results_dict['metrics/mAP50-95(B)']

# Create a bar plot for the metrics
metric_names = ['Precision', 'Recall', 'mAP50', 'mAP50-95']
metric_values = [precision, recall, mAP50, mAP50_95]

plt.figure(figsize=(8, 6))
plt.bar(metric_names, metric_values, color=['blue', 'green', 'orange', 'red'])
plt.title('Model Performance Metrics')
plt.ylabel('Score')
plt.ylim([0, 1])  # Set y-axis limits to 0-1 for better visualization
plt.grid(axis='y', linestyle='--')

# Add value labels on top of the bars
for i, v in enumerate(metric_values):
    plt.text(i, v + 0.02, f'{v:.2f}', ha='center', va='top', fontweight='bold')

plt.show()  # Display the plot

import pandas as pd
import matplotlib.pyplot as plt

# Path to results.csv
results_csv_path = "runs/detect/train/results.csv"  # Update if needed
df = pd.read_csv(results_csv_path)

# Print available columns to verify column names
print(df.columns)

# Create a figure
fig, ax1 = plt.subplots(figsize=(12, 6))

# Plot loss values (left y-axis) - Update column names if needed
# Check printed columns and replace 'train/box_loss', 'train/cls_loss', 'train/obj_loss' with actual column names from your CSV.
ax1.plot(df['epoch'], df['train/box_loss'], label='Box Loss', color='blue', linewidth=2)
ax1.plot(df['epoch'], df['train/cls_loss'], label='Class Loss', color='green', linewidth=2)
ax1.plot(df['epoch'], df['train/dfl_loss'], label='Distribution Focal Loss', color='orange', linewidth=2)
ax1.set_xlabel('Epoch')
ax1.set_ylabel('Loss', color='black')
ax1.tick_params(axis='y', labelcolor='black')
ax1.grid(True)

# Create a second y-axis for mAP
ax2 = ax1.twinx()
ax2.plot(df['epoch'], df['metrics/mAP50(B)'], label='mAP@50(B)', color='red', linestyle='--', linewidth=2)
ax2.plot(df['epoch'], df['metrics/mAP50-95(B)'], label='mAP@50-95(B)', color='purple', linestyle='--', linewidth=2)
ax2.set_ylabel('mAP', color='black')
ax2.tick_params(axis='y', labelcolor='black')

# Combine legends from both axes
lines, labels = ax1.get_legend_handles_labels()
lines2, labels2 = ax2.get_legend_handles_labels()
ax1.legend(lines + lines2, labels + labels2, loc='upper right')

# Title
plt.title('Training Loss and mAP Curves (YOLOv8)')
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
import numpy as np

# Replace with your actual predictions and ground truth
true_labels = []  # Append actual class labels from ground truth
pred_labels = [] # Append predicted class labels from your model

# Iterate through predictions and ground truth for each image:
# ... (Code to load predictions and ground truth, and match bounding boxes using IoU) ...

# Class names (adjust based on your dataset)
class_names = ['Benign', 'Early', 'Pre', 'Pro']

# Generate confusion matrix
cm = confusion_matrix(true_labels, pred_labels, labels=class_names)
cm_percent = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis] * 100  # convert to percentages

# Plot
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=class_names, yticklabels=class_names, cbar=False)
for i in range(len(class_names)):
    for j in range(len(class_names)):
        plt.text(j + 0.5, i + 0.7, f"({cm_percent[i, j]:.2f}%)",
                 ha='center', va='center', color='black', fontsize=10)

plt.xlabel("Predicted Label")
plt.ylabel("True Label")
plt.title("Confusion Matrix for Leukemia Detection (YOLOv8)")
plt.tight_layout()
plt.show()

results = model("/content/Leukemia-Cancer-Detection-6/test/images/WBC-Benign-005_jpg.rf.274d93de8060ffeb0d2cbf5f0f9c2891.jpg")
results[0].show()        # Displays image with predictions
results[0].save()        # Saves in runs/detect/predict

import os

test_dir = "/content/Leukemia-Cancer-Detection-6/test/images"

for img_file in os.listdir(test_dir):
    if img_file.endswith(".jpg") or img_file.endswith(".png"):
        img_path = os.path.join(test_dir, img_file)
        results = model(img_path)
        results[0].save()

import IPython.display as display
from PIL import Image

display.display(Image.open("/content/runs/detect/train/train_batch2.jpg"))

model = YOLO("runs/detect/train/weights/best.pt")

results1 = model("/kaggle/input/leukemia/Original/Early/WBC-Malignant-Early-001.jpg")
results1[0].show()  # This will display the image with bounding boxes and class labels

for r in results1:
    for box in r.boxes:
        cls_id = int(box.cls[0])
        confidence = float(box.conf[0])
        class_name = model.names[cls_id]
        print(f"Detected: {class_name} ({confidence:.2f})")

import os
import csv
from ultralytics import YOLO
from PIL import Image
import IPython.display as display

# Load the trained model
model = YOLO("runs/detect/train/weights/best.pt")

# Set the path to your custom folder with test images
custom_test_folder = "/merged"
output_csv_path = "classification_results.csv"

# Supported image extensions
image_extensions = (".jpg", ".jpeg", ".png")

# Prepare CSV file
with open(output_csv_path, mode='w', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(["Image", "Class", "Confidence"])

    # Go through each image
    for img_file in os.listdir(custom_test_folder):
        if img_file.lower().endswith(image_extensions):
            img_path = os.path.join(custom_test_folder, img_file)
            print(f"\n Processing image: {img_file}")

            # Run inference
            results = model(img_path)

            # Show image with bounding boxes (optional)
            results[0].show()
            display.display(Image.open(img_path))

            # Write results to CSV
            for box in results[0].boxes:
                cls_id = int(box.cls[0])
                confidence = float(box.conf[0])
                class_name = model.names[cls_id]
                writer.writerow([img_file, class_name, round(confidence, 2)])
                print(f" Detected: {class_name} (Confidence: {confidence:.2f})")

print(f"\n All results saved in: {output_csv_path}")

